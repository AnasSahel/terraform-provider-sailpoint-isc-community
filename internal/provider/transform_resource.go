package provider

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/sailpoint-oss/golang-sdk/v2/api_v2025"
)

type transformResourceModel struct {
	Id             types.String `tfsdk:"id"`
	Name           types.String `tfsdk:"name"`
	Type           types.String `tfsdk:"type"`
	Internal       types.Bool   `tfsdk:"internal"`
	AttributesJson types.String `tfsdk:"attributes_json"`
	// Attributes types.Dynamic `tfsdk:"attributes"`
}

// Ensure the implementation satisfies the expected interfaces.
var (
	_ resource.Resource              = &transformResource{}
	_ resource.ResourceWithConfigure = &transformResource{}
)

// Configure adds the provider configured client to the resource.
func (r *transformResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Add a nil check when handling ProviderData because Terraform
	// sets that data after it calls the ConfigureProvider RPC.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*api_v2025.APIClient)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *api_v2025.APIClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

// NewTransformResource is a helper function to simplify the provider implementation.
func NewTransformResource() resource.Resource {
	return &transformResource{}
}

// transformResource is the resource implementation.
type transformResource struct {
	client *api_v2025.APIClient
}

// Metadata returns the resource type name.
func (r *transformResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_transform"
}

// Schema defines the schema for the resource.
func (r *transformResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "The ID of the transform, generated by SailPoint ISC.",
				MarkdownDescription: "The ID of the transform, generated by SailPoint ISC.\n\nThis field is required to import existing transforms.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the transform.",
				MarkdownDescription: "The name of the transform.\n\nThis field is required to import existing transforms.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of the transform.",
				MarkdownDescription: "The type of the transform.\n\nThis field is required to import existing transforms.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"internal": schema.BoolAttribute{
				Computed:            true,
				Optional:            true,
				Description:         "Whether the transform is internal.",
				MarkdownDescription: "Whether the transform is internal.\n\nThis field is computed and cannot be set.",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
			"attributes_json": schema.StringAttribute{
				Required:            true,
				Description:         "A JSON string representing the attributes of the transform.",
				MarkdownDescription: "A JSON string representing the attributes of the transform.\n\nThis field is required to import existing transforms.",
			},
		},
	}
}

// Create creates the resource and sets the initial Terraform state.
func (r *transformResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan transformResourceModel

	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Prepare attributes: convert from JSON string to map
	var attributesMap map[string]interface{}
	err := json.Unmarshal([]byte(plan.AttributesJson.ValueString()), &attributesMap)
	if err != nil {
		resp.Diagnostics.AddError(
			"Invalid Transform Attributes JSON",
			fmt.Sprintf("Failed to parse attributes_json: %s. Please ensure the JSON is valid and properly formatted.", err.Error()),
		)
		return
	}

	transform := api_v2025.NewTransform(plan.Name.ValueString(), plan.Type.ValueString(), attributesMap)

	// Call SailPoint API to create the transform
	transformResponse, response, err := r.client.TransformsAPI.CreateTransform(context.Background()).Transform(*transform).Execute()
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Create Transform",
			fmt.Sprintf("SailPoint API error while creating transform '%s': %s\nHTTP Response: %v",
				plan.Name.ValueString(),
				err.Error(),
				response,
			),
		)
		return
	}

	// Map response
	attributesByte, err := json.Marshal(transformResponse.GetAttributes())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Serialize Transform Attributes",
			fmt.Sprintf("Unable to marshal transform attributes to JSON: %s",
				err.Error(),
			),
		)
		return
	}

	// Map response body to schema model and populate Computed attribute
	plan.Id = types.StringValue(transformResponse.GetId())
	plan.Internal = types.BoolValue(transformResponse.GetInternal())
	plan.Name = types.StringValue(transformResponse.GetName())
	plan.Type = types.StringValue(transformResponse.GetType())
	plan.AttributesJson = types.StringValue(string(attributesByte))

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Read refreshes the Terraform state with the latest data.
func (r *transformResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state transformResourceModel

	diags := req.State.Get(ctx, &state)
	resp.Diagnostics.Append(diags...)

	if resp.Diagnostics.HasError() {
		return
	}

	transform, response, err := r.client.TransformsAPI.GetTransform(context.Background(), state.Id.ValueString()).Execute()
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Read Transform",
			fmt.Sprintf("SailPoint API error while reading transform with ID '%s': %s\nHTTP Response: %v",
				state.Id.ValueString(),
				err.Error(),
				response,
			),
		)
		return
	}

	transformAttributes, err := json.Marshal(transform.GetAttributes())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Serialize Transform Attributes",
			fmt.Sprintf("Unable to marshal transform attributes to JSON during read operation: %s",
				err.Error(),
			),
		)
		return
	}

	// Map response body to schema model
	state.Internal = types.BoolValue(transform.GetInternal())
	state.Name = types.StringValue(transform.GetName())
	state.Type = types.StringValue(transform.GetType())
	state.AttributesJson = types.StringValue(string(transformAttributes))

	diags = resp.State.Set(ctx, state)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *transformResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan transformResourceModel

	diags := req.Plan.Get(ctx, &plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Generate the request body
	var attributesMap map[string]interface{}
	err := json.Unmarshal([]byte(plan.AttributesJson.ValueString()), &attributesMap)
	if err != nil {
		resp.Diagnostics.AddError(
			"Invalid Transform Attributes JSON",
			fmt.Sprintf("Failed to parse attributes_json during update: %s. Please ensure the JSON is valid and properly formatted.",
				err.Error(),
			),
		)
		return
	}

	transform := api_v2025.NewTransform(plan.Name.ValueString(), plan.Type.ValueString(), attributesMap)
	transformResponse, httpResponse, err := r.client.TransformsAPI.UpdateTransform(context.Background(), plan.Id.ValueString()).Transform(*transform).Execute()
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Update Transform",
			fmt.Sprintf("SailPoint API error while updating transform '%s' (ID: %s): %s\nHTTP Response: %v",
				plan.Name.ValueString(),
				plan.Id.ValueString(),
				err.Error(),
				httpResponse,
			),
		)
		return
	}

	// Map the response
	transformAttributes, err := json.Marshal(transformResponse.GetAttributes())
	if err != nil {
		resp.Diagnostics.AddError(
			"Failed to Serialize Transform Attributes",
			fmt.Sprintf("Unable to marshal transform attributes to JSON during update operation: %s",
				err.Error(),
			),
		)
		return
	}

	// Map response body to schema model
	plan.Internal = types.BoolValue(transformResponse.GetInternal())
	plan.Name = types.StringValue(transformResponse.GetName())
	plan.Type = types.StringValue(transformResponse.GetType())
	plan.AttributesJson = types.StringValue(string(transformAttributes))

	diags = resp.State.Set(ctx, plan)
	resp.Diagnostics.Append(diags...)
	if resp.Diagnostics.HasError() {
		return
	}
}

// Delete deletes the resource and removes the Terraform state on success.
func (r *transformResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
}
